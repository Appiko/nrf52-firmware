

#include <stdbool.h>
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include "nrf.h"
#include "boards.h"

#include "log.h"
#include "nrf_util.h"
#include "hal_gpio.h"
#include "hal_uart.h"
#include "hal_nop_delay.h"
#include "hal_clocks.h"

#include "ms_timer.h"
#include "profiler_timer.h"

#include "nrf_nvic.h"
#include "ble.h"
#include "ble_gap.h"
#include "nrf_sdm.h"
#include "app_error.h"
#include "sd_evt_handler.h"

#define TRIGGER 2
#define FOCUS 3

uint32_t if_toggle_five(uint32_t pin_trigger, uint32_t pin_focus);
/**To store the MAC address of device whose name and UUID matches*/
static uint8_t sense_pi_mac_addr[] = {0,0,0,0,0,0};

uint8_t * my_uart_rx_buffer;

static uint32_t pir_flag = 0;

uint8_t scan_data_buffer[50];

volatile uint32_t conn_terminate_flag = 0;

uint8_t prodcut_id_from_scan_resp[BLE_GAP_SCAN_BUFFER_MAX] = {};

void check_pir(void);

void recv_data(uint8_t * buffer);


ble_data_t sys_lvl_app_scan_buffer = {
    scan_data_buffer,
    (BLE_GAP_SCAN_BUFFER_MAX),
};

static ble_gap_scan_params_t const sys_lvl_app_scan_params  =
{
    .active   = 1,
    .interval = (BLE_GAP_SCAN_INTERVAL_MAX),
    .window   = (BLE_GAP_SCAN_WINDOW_MAX),
    .extended = 0,
    .report_incomplete_evts = 0,
    .channel_mask = {0,0,0,0,0},
    .timeout           = BLE_GAP_SCAN_TIMEOUT_UNLIMITED,
    .scan_phys         = BLE_GAP_PHY_AUTO,
    .filter_policy     = BLE_GAP_SCAN_FP_ACCEPT_ALL,
};

static ble_gap_conn_params_t const sys_lvl_conn_params = 
{
    .min_conn_interval = BLE_GAP_CP_MIN_CONN_INTVL_MIN,
    .max_conn_interval = BLE_GAP_CP_MAX_CONN_INTVL_MIN,
    .slave_latency = BLE_GAP_CP_SLAVE_LATENCY_MAX,
    .conn_sup_timeout = BLE_GAP_CP_CONN_SUP_TIMEOUT_MAX,
};

static ble_gap_addr_t my_peer_addr;

#if 0
/**
 * @brief Function to start scanning again.
 */
void scan_start();
#endif
/**
 * @brief Function to generate table of scanned devices with MAC addresses
 */

void conn_to_sense_pi(void);

/**
 * @brief Function to extract Product ID from Scan response data.
 */
void extract_product_id(void);


static ble_gap_evt_adv_report_t my_adv_report;

/**
 * @brief Handler which will address all the SoC related events
 *  generated by the SoftdDevice.
 * @param evt The pointer to the buffer containing all the data
 *  related to the event
 */
static void ble_evt_handler(ble_evt_t * evt)
{
    switch(evt->header.evt_id)
    {
        case BLE_GAP_EVT_CONNECTED:
        {
                uint32_t err_code;
                err_code = sd_ble_gap_disconnect(evt->evt.gap_evt.conn_handle, BLE_HCI_REMOTE_USER_TERMINATED_CONNECTION);
                APP_ERROR_CHECK(err_code);
            break;
        }
        case BLE_GAP_EVT_DISCONNECTED:
        {
                conn_terminate_flag = 1;
            break;
        }
        case BLE_GAP_EVT_CONN_PARAM_UPDATE:
    
            break;
        case BLE_GAP_EVT_ADV_SET_TERMINATED:
    
            break;
        case BLE_GATTS_EVT_WRITE:
    
            break;
        case BLE_GAP_EVT_ADV_REPORT:
        {
                my_adv_report = (evt->evt.gap_evt.params.adv_report);

                uint32_t mac_flag = 1;
                for(uint32_t addr_byte = BLE_GAP_ADDR_LEN; addr_byte > 0; addr_byte--)
                {
                    if(evt->evt.gap_evt.params.adv_report.peer_addr.addr[(addr_byte - 1)] != sense_pi_mac_addr[(addr_byte - 1)])
                    {
                        mac_flag = 0;
                    }
                }
                if(mac_flag)
                {
                    my_peer_addr = evt->evt.gap_evt.params.adv_report.peer_addr;
                    if(my_adv_report.type.scan_response == 1 && my_adv_report.rssi >= (-55))
                    {
                        uint32_t err_code;
                        err_code = sd_ble_gap_connect(&my_peer_addr, &sys_lvl_app_scan_params, &sys_lvl_conn_params, BLE_CONN_CFG_TAG_DEFAULT);
                        APP_ERROR_CHECK(err_code);
                        memcpy(prodcut_id_from_scan_resp, my_adv_report.data.p_data, my_adv_report.data.len);
#if 0
                        log_printf("LENGTH: %d\n",my_adv_report.data.len);
                        for (uint32_t char_arr_cnt = 0; char_arr_cnt <  evt->evt.gap_evt.params.adv_report.data.len; char_arr_cnt++)
                        {
                            log_printf("%02x ",prodcut_id_from_scan_resp[char_arr_cnt]);
                        }
                        log_printf("\n");
#endif
                        extract_product_id();
                        if(err_code != 0)
                        {
                        }
                    }
                    else
                    {
                        conn_to_sense_pi();
                    }
                }
                else
                {
                    conn_to_sense_pi();
                }
            break;
        }
        case BLE_GAP_EVT_TIMEOUT:
        {

    
            break;
        }
 
    }
    return;
}

/**
 * @brief Handler which will address all the SoC related events
 *  generated by the SoftdDevice.
 * @param evt_id The ID of the SoC event generated
 */
static void soc_evt_handler(uint32_t evt_id)
{
    log_printf("soc evt %x\n", evt_id);
}



/**
 * @brief Function for initializing the BLE stack by enabling the
 *  SoftDevice and the BLE event interrupt
 * */
void ble_stack_init(void)
{
    uint32_t err_code;
    nrf_clock_lf_cfg_t cfg = BOARD_LFCLKSRC_STRUCT;
    err_code = sd_softdevice_enable(&cfg, app_error_fault_handler);
    APP_ERROR_CHECK(err_code);
    uint32_t app_ram_start = 0x200032C8;
//    log_printf("Init %x", app_ram_start);
    err_code = sd_ble_enable(&app_ram_start);
//    log_printf(" RAM needed %x\n", app_ram_start);
    APP_ERROR_CHECK(err_code);

    sd_evt_handler_init(ble_evt_handler, soc_evt_handler);

}

void scan_start()
{
    ble_stack_init();
    uint32_t err_code;
    err_code = sd_ble_gap_scan_start(&sys_lvl_app_scan_params, &sys_lvl_app_scan_buffer);
    APP_ERROR_CHECK(err_code);
    if (!err_code)
    {
        log_printf("\nSTART\n");
    }
}






int main(void)
{
//    log_printf("\n\nHello SensePi World!\n");
    lfclk_init(LFCLK_SRC_Xtal);
    hal_uart_init(HAL_UART_BAUD_1M, recv_data);
    while (true)
    {
        if(conn_terminate_flag == 1)
        {
            uint32_t err_code;
            err_code = sd_softdevice_disable();
            APP_ERROR_CHECK(err_code);
            if(err_code == 0)
            {
                log_printf("BLE_Status : 1\n");
            }
            else
            {
                log_printf("BLE_Status : 0\n");
            }
            for(uint32_t addr_byte = BLE_GAP_ADDR_LEN; addr_byte > 0; addr_byte--)
            {
                sense_pi_mac_addr[(addr_byte - 1)] = 0;
            }
            conn_terminate_flag = 0;            
        }
    }
}






void conn_to_sense_pi()
{    
    static uint8_t data_to_comp[23] = {};
    static const uint8_t sense_pi_data[23] = {0x53, 0x65, 0x6e, 0x73, 0x65, 0x50, 0x69, 0x0a, 0xde, 0xfb, 0x07, 0x74, 0x83, 0x66, 0xb0, 0x0d, 0x48, 0xf5, 0x07, 0x50, 0xdc, 0x73, 0x3c};
    uint32_t cpy_arr_cnt = 0;
    uint32_t pst_arr_cnt = 0;
    uint32_t arr_cnt = 0;
    uint32_t comp_flag = 1;
    uint8_t * mac_addr_value = my_adv_report.peer_addr.addr;
    for(cpy_arr_cnt = 5, pst_arr_cnt = 0; cpy_arr_cnt < 12; cpy_arr_cnt++, pst_arr_cnt++)
    {
        data_to_comp[pst_arr_cnt] = my_adv_report.data.p_data[cpy_arr_cnt];
    }
    for(cpy_arr_cnt = 14, pst_arr_cnt = 7; cpy_arr_cnt < 30; cpy_arr_cnt++, pst_arr_cnt++)
    {
        data_to_comp[pst_arr_cnt] = my_adv_report.data.p_data[cpy_arr_cnt];
    }
    for(arr_cnt = 0; arr_cnt < 23; arr_cnt++)
    {
        if(data_to_comp[arr_cnt] != sense_pi_data[arr_cnt])
        {
            comp_flag = 0;
        }
    }
    if(comp_flag)
    {
        for(uint32_t addr_byte = BLE_GAP_ADDR_LEN; addr_byte > 0; addr_byte--)
        {
            sense_pi_mac_addr[(addr_byte - 1)] = mac_addr_value[(addr_byte - 1)];
        }        
    }
    uint32_t err_code;
    err_code = sd_ble_gap_scan_start( NULL , &sys_lvl_app_scan_buffer);
    APP_ERROR_CHECK(err_code);
}



void extract_product_id(void)
{
    uint8_t product_id[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
    memcpy(product_id,&prodcut_id_from_scan_resp[5],16);
    log_printf("Product_ID : ");
    for(uint32_t char_cnt = 0; char_cnt < 16; char_cnt++)
    {
        log_printf("%c", product_id[char_cnt]);    
    }
    log_printf("\n");
}



uint32_t if_pulse(uint32_t pin_trigger, uint32_t pin_focus)
{
    uint32_t toggle_flag             = 0;
    uint32_t trigger_flag            = 0;
    uint32_t focus_flag              = 0;
    uint32_t prev_state_trigger      = 0;
    uint32_t prev_state_focus        = 0;
    uint32_t current_state_trigger   = 0;
    uint32_t current_state_focus     = 0;
    uint32_t focus_cnt               = 0;
    uint32_t trigger_cnt             = 0;
    prev_state_trigger = hal_gpio_pin_read(pin_trigger);
    prev_state_focus = hal_gpio_pin_read(pin_focus);
    current_state_trigger = hal_gpio_pin_read(pin_trigger);
    current_state_focus = hal_gpio_pin_read(pin_focus);
    profiler_timer_init();
    while(read_time_us() < 200000)
    {
        if(current_state_trigger != prev_state_trigger)
        {
            current_state_trigger = prev_state_trigger;
            trigger_cnt++;
        }
        else
        {
            current_state_trigger = hal_gpio_pin_read(TRIGGER);
        }
        if(current_state_focus != prev_state_focus)
        {
            current_state_focus = prev_state_focus;
            focus_cnt++;
        }
        else
        {
            current_state_focus = hal_gpio_pin_read(FOCUS);
        }
    }
    if(trigger_cnt >= 2)
    {
        trigger_flag = 1;
    }
    if(focus_cnt >= 2)
    {
        focus_flag = 1;
    }
    if((trigger_flag && focus_flag) == 1)
    {
        toggle_flag = 1;
    }
    else
    {
        toggle_flag = 0;
    }
    profiler_timer_deinit();
    return toggle_flag;
}
void check_pir(void)
{
    hal_gpio_cfg_input(TRIGGER, HAL_GPIO_PULL_DISABLED);
    hal_gpio_cfg_input(FOCUS, HAL_GPIO_PULL_DISABLED);
    pir_flag = if_pulse(TRIGGER, FOCUS);
    if(pir_flag == 1)
    {
        log_printf("PIR_Status : 1\n");
    } 
    else
    {
        log_printf("PIR_Status : 0\n");
    }
    log_printf("END\n");
}


void recv_data(uint8_t * buffer)
{
    char temp_str[] = {};
    char * start_pir = "PIR\0";
    char * start_scan = "SCN\n";
    memcpy(temp_str, buffer, sizeof(start_pir));
    if(memcmp(temp_str, start_pir,(sizeof(start_pir))) == 0)
    {
        check_pir();
    }
    else if(memcmp(temp_str, start_scan,(sizeof(start_scan) - 1)) == 0)
    {
        scan_start();
    }
    else
    {
    }
    return;
}

