#### To be included at the end of a makefile ####

ifndef BOARD
${error BOARD not specified}
endif

ifndef SDK_DIR
${error SDK_DIR not specified in application Makefile. Needed to find the start-up and CMSIS code.}
endif

ifndef CPU
${error CPU not specified in board Makefile. Needed for CFLAGS.}
endif

ifndef SOC_FAMILY
${error SOC_FAMILY not specified in board Makefile.}
endif

ifndef SOC_NAME
${error SOC_NAME not specified in board Makefile.}
endif

ifndef SOC_VERSION
${error SOC_VERSION not specified in board Makefile.}
endif

ifndef SD_USED
${error SD_USED not specified in application Makefile.}
endif

#Lower and upper case versions of SoC family, SoC name and SD used
SOC_FAMILY_LC  = $(shell echo $(SOC_FAMILY) | tr A-Z a-z)
SOC_FAMILY_UC  = $(shell echo $(SOC_FAMILY) | tr a-z A-Z)

SOC_NAME_LC  = $(shell echo $(SOC_NAME) | tr A-Z a-z)
SOC_NAME_UC  = $(shell echo $(SOC_NAME) | tr a-z A-Z)

SD_USED_LC  = $(shell echo $(SD_USED) | tr A-Z a-z)
SD_USED_UC  = $(shell echo $(SD_USED) | tr a-z A-Z)

GCC_PREFIX          := arm-none-eabi

CC      := $(GCC_PREFIX)-gcc
AS      := $(GCC_PREFIX)-as
AR      := $(GCC_PREFIX)-ar -r
LD      := $(GCC_PREFIX)-ld
NM      := $(GCC_PREFIX)-nm
OBJDUMP := $(GCC_PREFIX)-objdump
OBJCOPY := $(GCC_PREFIX)-objcopy
GDB     := $(GCC_PREFIX)-gdb
SIZE    := $(GCC_PREFIX)-size

MK	:= mkdir -p
RM	:= rm -rf

### JLink related stuff ###
JLINK_DIR           := /opt/SEGGER/JLink
JLINK_EXE 			= $(JLINK_DIR)/JLinkExe -Speed 4000 -If SWD

ifdef SLNO
JLINK 				= $(JLINK_EXE) -SelectEmuBySN $(SLNO)
else
JLINK 				= $(JLINK_EXE)
endif
JLINKGDBSERVER	= $(JLINK_DIR)/JLinkGDBServer
JLINKDEVICE			= $(SOC_FAMILY_LC)

### nrfjprog related stuff ###
NRFJPROG_DIR    = ../../utils/nrfjprog
ifdef SLNO
NRFJPROG        = $(NRFJPROG_DIR)/nrfjprog -f $(SOC_FAMILY_LC) -s $(SLNO)
else
NRFJPROG        = $(NRFJPROG_DIR)/nrfjprog -f $(SOC_FAMILY_LC)
endif

### NVMC Address defines ###
NVMC_CONFIG_ADRS	 = 4001E504
NVMC_ERASEALL_ADRS = 4001E50C


### Folder structure Variables ####
OUTPUT_NAME     = $(APPLN)
OUTPUT_MERGED   = $(APPLN)_$(SD_USED_LC)
OUTPUT_DIR      = build
OBJ_DIR         = obj

### Verbosity control. Use  make V=1  to get verbose builds.
ifeq ($(V),1)
  Q=
else
  Q=@
endif

# Include directories
INCLUDEDIRS	+= $(SDK_DIR)/device
INCLUDEDIRS	+= $(SDK_DIR)/toolchain
INCLUDEDIRS	+= $(SDK_DIR)/toolchain/cmsis/include
INCLUDEDIRS	+= /usr/arm-none-eabi/include/

SOFTDEVICE  = $(SDK_DIR)/softdevice/$(SD_USED_LC)/hex/$(shell ls $(SDK_DIR)/softdevice/$(SD_USED_LC)/hex)
SD_PRESENT  = SOFTDEVICE_PRESENT

LD_SCRIPT 	= $(SDK_DIR)/softdevice/$(SD_USED_LC)/toolchain/armgcc/armgcc_$(SD_USED_LC)_$(SOC_NAME_LC)_$(SOC_VERSION).ld

### Source files ###
# Project Source
C_SRC  += system_$(SOC_FAMILY_LC).c

### Assembly source files
ASSEMBLY_SRC = gcc_startup_$(SOC_FAMILY_LC).S

### Compiler related stuff ###
#Small size, good for cache
CFLAGS	= -Os
#Max info for the debugger
CFLAGS  += -ggdb3
CFLAGS	+= -mcpu=$(CPU)
CFLAGS	+= -mthumb
CFLAGS	+= -mabi=aapcs
ifdef FPU_FLAG
CFLAGS	+= $(FPU_FLAG)
endif
#Use the GCC extensions to C
CFLAGS	+= --std=gnu11
#Give a warning when using the GCC extensions to C
CFLAGS  += -pedantic
CFLAGS	+= -Wall -Werror
# keep every function in separate section, this allows linker to discard unused ones
CFLAGS += -ffunction-sections -fdata-sections -fno-strict-aliasing
CFLAGS += -fno-builtin --short-enums -flto
#CFLAGS from the application Makefile
CFLAGS  += $(CFLAGS_APP)
#CFLAGS from the board Makefile
CFLAGS  += $(CFLAGS_BOARD)
CFLAGS	+= -D$(SOC_FAMILY_UC)
CFLAGS  += -D$(SOC_NAME_UC)
CFLAGS	+= -D$(BOARD)
CFLAGS  += -D$(SD_PRESENT)
CFLAGS  += -D$(SD_USED_UC)
CFLAGS  += -DNRF_SD_BLE_API_VERSION=3 #TODO get from Makefile
#TODO remove if not required
CFLAGS  += -DSWI_DISABLE0 
CFLAGS	+= $(patsubst %,-I%, $(INCLUDEDIRS))

### Linker related stuff ###
LDDIRS	+= $(SDK_DIR)/softdevice/$(SD_USED_LC)/toolchain/armgcc/
LDDIRS	+= $(SDK_DIR)/toolchain/gcc/

LDFLAGS += -Xlinker
LDFLAGS += -Map=$(OUTPUT_DIR)/$(OUTPUT_NAME).map
# use newlib in nano version
LDFLAGS += --specs=nano.specs
LDFLAGS += -lc -lnosys
LDFLAGS += -mcpu=$(CPU) 
LDFLAGS += -mthumb 
LDFLAGS += -mabi=aapcs
ifdef FPU_FLAG
LDFLAGS	+= $(FPU_FLAG)
endif
LDFLAGS += -T$(LD_SCRIPT)
# let linker to dump unused sections
LDFLAGS += -Wl,--gc-sections -flto
LDFLAGS	+= $(patsubst %,-L%, $(LDDIRS))
#TODO Add linking time optimizations

# Sorting removes duplicates
BUILD_DIRS := $(sort $(OBJ_DIR) $(OUTPUT_DIR) )

# Make a list of source paths
C_SRC_DIRS  += $(SDK_DIR)/toolchain

ASSEMBLY_SRC_DIRS	= $(SDK_DIR)/toolchain/gcc

# Object files
C_OBJ 			= $(addprefix $(OBJ_DIR)/, $(C_SRC:.c=.o))
ASSEMBLY_OBJ 	= $(addprefix $(OBJ_DIR)/, $(ASSEMBLY_SRC:.S=.o))

DOXY_EDITS		= INPUT = $(DOC_DIR) $(CODEBASE_DIR) $(PLATFORM_DIR) ..\n
DOXY_EDITS	   += OUTPUT_DIRECTORY = $(DOC_DIR)/build\n
DOXY_EDITS	   += LAYOUT_FILE = $(DOC_DIR)/DoxygenLayout.xml\n

# Set source lookup paths
vpath %.c $(C_SRC_DIRS)
vpath %.S $(ASSEMBLY_SRC_DIRS)

# Include automatically previously generated dependencies
-include $(addprefix $(OBJ_DIR)/, $(C_OBJ:.o=.d))

### Rules ###
# Default build target
.PHONY : all size clean

size :
	$(SIZE) $(OUTPUT_DIR)/$(OUTPUT_NAME).elf

all : $(OUTPUT_DIR)/$(OUTPUT_NAME).bin $(OUTPUT_DIR)/$(OUTPUT_NAME).hex

clean : 
	$(RM) $(OUTPUT_DIR)/*
	$(RM) $(OBJ_DIR)/*

$(BUILD_DIRS) : 
	@echo 
	@echo "Creating directories"
	- $(MK) $@

# Create objects from C source files
$(OBJ_DIR)/%.o : %.c
	@echo "Build header dependencies & compiling file: " $<
	$(Q)$(CC) $(CFLAGS) -M $< -MF "$(@:.o=.d)" -MT $@	
	$(Q)$(CC) $(CFLAGS) -c -o $@ $<

## Assemble .S files
$(OBJ_DIR)/%.o : %.S
	@echo "Compiling: " $<
	$(Q)$(CC) $(CFLAGS) -c -o $@ $<

## Link C and assembler objects to an .elf file
$(OUTPUT_DIR)/$(OUTPUT_NAME).elf : $(BUILD_DIRS) $(C_OBJ) $(ASSEMBLY_OBJ)
	@echo
	@echo "Linking object files to create $(OUTPUT_DIR)/$(OUTPUT_NAME).elf" 
	$(Q)$(CC) $(LDFLAGS) $(C_OBJ) $(ASSEMBLY_OBJ) -o $(OUTPUT_DIR)/$(OUTPUT_NAME).elf

## Create binary .bin file from the .elf file
$(OUTPUT_DIR)/$(OUTPUT_NAME).bin : $(OUTPUT_DIR)/$(OUTPUT_NAME).elf
	@echo
	@echo "Create binary(.bin) file from: " $<
	$(Q)$(OBJCOPY) -O binary $(OUTPUT_DIR)/$(OUTPUT_NAME).elf $(OUTPUT_DIR)/$(OUTPUT_NAME).bin

## Create binary .hex file from the .elf file
$(OUTPUT_DIR)/$(OUTPUT_NAME).hex : $(OUTPUT_DIR)/$(OUTPUT_NAME).elf
	@echo "Create hex file from: " $<
	$(Q)$(OBJCOPY) -O ihex $(OUTPUT_DIR)/$(OUTPUT_NAME).elf $(OUTPUT_DIR)/$(OUTPUT_NAME).hex
	@echo "Combined $(SD_USED_LC).hex and $(APPLN).hex files to form $(OUTPUT_MERGED).hex"
	$(Q)srec_cat $(PWD)/$(SOFTDEVICE) -Intel $(PWD)/$(OUTPUT_DIR)/$(OUTPUT_NAME).hex -Intel -O $(PWD)/$(OUTPUT_DIR)/$(OUTPUT_MERGED).hex -Intel --line-length=44;
	
## Program device
upload:
	$(RM) $(OUTPUT_DIR)/upload.jlink
	echo "device $(JLINKDEVICE)\nw4 $(NVMC_CONFIG_ADRS) 1\nloadfile $(PWD)/$(OUTPUT_DIR)/$(OUTPUT_MERGED).hex\nr\ng\nqc\n" > $(OUTPUT_DIR)/upload.jlink
	@echo "Starting uploading"
	$(JLINK) $(OUTPUT_DIR)/upload.jlink
	@echo "Done uploading"

recover:
	$(NRFJPROG) --recover

eraseall: 
	$(NRFJPROG) --eraseall

pinreset:
	$(NRFJPROG) --pinresetenable
	$(NRFJPROG) --pinreset

doc:
	( cat $(DOC_DIR)/Appiko.doxyfile ; echo "$(DOXY_EDITS)" ) | doxygen -

.PHONY: upload eraseall recover pinreset doc

